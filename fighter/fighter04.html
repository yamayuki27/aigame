<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>3D Planet Fighter - Flat Shading Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffcc00;
            font-family: 'Courier New', Courier, monospace;
            font-size: 20px;
            pointer-events: none;
            text-shadow: 2px 2px 4px #000;
        }
    </style>
</head>

<body>
    <div id="ui">MISSION: DESTROY RED BASES<br>PLAYER HP: 100<br>AMMO: 4/4</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ゲーム定数 ---
        const PLANET_RADIUS = 100;
        const SHIP_SIZE = 3.75;
        const ALTITUDE = 2;
        const BASE_RADIUS = 3;
        const BASE_HEIGHT = 5;
        const MAX_POOL_BULLETS = 8;
        const SIMULTANEOUS_BULLETS = 4;

        // 速度を前回の1.5倍に設定
        const FORWARD_SPEED = 0.0025;
        const TURN_SPEED = 0.016;
        const BULLET_SPEED = 0.01;

        let playerHP = 100;
        let bases = [];
        let particles = [];
        let rings = []; // 輪っかエフェクト用の配列
        let score = 0;

        // --- シーン・カメラ・レンダラー ---
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ライト
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 100, 50);
        scene.add(sunLight);

        // --- 惑星テクスチャ生成 ---
        function createAdvancedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(canvas.width, canvas.height);

            const random = (ix, iy) => {
                const dot = ix * 12.9898 + iy * 78.233;
                const r = (Math.sin(dot) * 43758.5453) % 1;
                return r < 0 ? r + 1 : r;
            };

            const valueNoise = (x, y) => {
                const ix = Math.floor(x);
                const iy = Math.floor(y);
                const fx = x - ix;
                const fy = y - iy;
                const sx = fx * fx * (3 - 2 * fx);
                const sy = fy * fy * (3 - 2 * fy);
                const v00 = random(ix, iy);
                const v10 = random(ix + 1, iy);
                const v01 = random(ix, iy + 1);
                const v11 = random(ix + 1, iy + 1);
                const nx0 = v00 + sx * (v10 - v00);
                const nx1 = v01 + sx * (v11 - v01);
                return nx0 + sy * (nx1 - nx0);
            };

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    let n = 0;
                    let amplitude = 1;
                    let frequency = 0.015;
                    let maxValue = 0;

                    for (let i = 0; i < 5; i++) {
                        n += valueNoise(x * frequency, y * frequency) * amplitude;
                        maxValue += amplitude;
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    n = n / maxValue;

                    const threshold = 0.7;
                    const isLand = n > threshold;

                    let r, g, b;
                    if (isLand) {
                        const height = (n - threshold) / (1.0 - threshold);
                        r = 120 + height * 40;
                        g = 90 + height * 50;
                        b = 50 + height * 20;
                    } else {
                        const depth = n / threshold;
                        r = 10 + depth * 30;
                        g = 50 + depth * 50;
                        b = 130 + depth * 80;
                    }

                    const distToPole = Math.min(y, canvas.height - y);
                    const snowRange = 20;
                    if (distToPole < snowRange) {
                        const ratio = 1 - (distToPole / snowRange);
                        const lerp = Math.pow(ratio, 3);
                        r = r + (255 - r) * lerp;
                        g = g + (255 - g) * lerp;
                        b = b + (255 - b) * lerp;
                    }

                    const idx = (x + y * canvas.width) * 4;
                    imgData.data[idx] = r;
                    imgData.data[idx + 1] = g;
                    imgData.data[idx + 2] = b;
                    imgData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
            return new THREE.CanvasTexture(canvas);
        }

        // 惑星の生成（フラットシェーディングを際立たせるために分割数を32,24に設定）
        const planet = new THREE.Mesh(
            new THREE.SphereGeometry(PLANET_RADIUS, 32, 24),
            new THREE.MeshStandardMaterial({
                map: createAdvancedTexture(),
                roughness: 0.8,
                flatShading: true // 全面フラットシェーディング
            })
        );
        scene.add(planet);

        // --- 戦闘機 ---
        const shipGroup = new THREE.Group();
        const shipMesh = new THREE.Mesh(
            new THREE.ConeGeometry(1.5, SHIP_SIZE, 5).rotateX(Math.PI / 2),
            new THREE.MeshStandardMaterial({ color: 0xffcc00, flatShading: true })
        );
        shipGroup.add(shipMesh);
        shipGroup.position.set(0, PLANET_RADIUS + ALTITUDE, 0);
        scene.add(shipGroup);

        // --- カメラ ---
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 0);
        camera.up.set(0, 0, 1);
        camera.lookAt(0, 0, 10);
        shipGroup.add(camera);

        // --- エフェクト関数（パーティクル・輪っか） ---
        function spawnParticles(pos, color, count, speed, life) {
            for (let i = 0; i < count; i++) {
                const p = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 4, 4),
                    new THREE.MeshBasicMaterial({ color: color }) // 光源無視
                );
                p.position.copy(pos);
                particles.push({
                    mesh: p,
                    vel: new THREE.Vector3((Math.random() - 0.5) * speed, (Math.random() - 0.5) * speed, (Math.random() - 0.5) * speed),
                    life: life
                });
                scene.add(p);
            }
        }

        function spawnRing(pos, color) {
            // ドーナツ型のGeometryで輪っかを作成
            const ringGeo = new THREE.TorusGeometry(BASE_RADIUS, 0.3, 4, 16);
            const ringMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1.0,
                side: THREE.DoubleSide // 光源無視
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(pos);
            ring.lookAt(new THREE.Vector3(0, 0, 0)); // 惑星の中心（真下）を向かせる
            scene.add(ring);
            rings.push({ mesh: ring, scale: 1.0, opacity: 1.0 });
        }

        // --- 敵基地作成 ---
        function createBases() {
            for (let i = 0; i < 4; i++) {
                const isPlayer = (i === 0);
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(BASE_RADIUS, BASE_RADIUS, BASE_HEIGHT, 8),
                    new THREE.MeshStandardMaterial({ color: isPlayer ? 0xffcc00 : 0xff4444, flatShading: true })
                );

                let pos;
                if (isPlayer) {
                    pos = new THREE.Vector3(0, PLANET_RADIUS, 0);
                } else {
                    do {
                        const phi = Math.acos(2 * Math.random() - 1);
                        const theta = 2 * Math.PI * Math.random();
                        pos = new THREE.Vector3().setFromSphericalCoords(PLANET_RADIUS, phi, theta);
                    } while (pos.distanceTo(new THREE.Vector3(0, PLANET_RADIUS, 0)) < 60);
                }

                base.position.copy(pos);
                const normal = pos.clone().normalize();
                base.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
                base.position.add(normal.clone().multiplyScalar(BASE_HEIGHT / 2));

                base.userData = {
                    hp: 8, active: true, dying: false, isPlayer,
                    normal, origin: base.position.clone(), sink: 0
                };
                scene.add(base);
                bases.push(base);
            }
        }
        createBases();

        // --- 弾丸プール ---
        const bulletPool = [];
        for (let i = 0; i < MAX_POOL_BULLETS; i++) {
            // 弾を1.5倍太く（0.2 -> 0.3）
            const b = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 2, 6).rotateX(Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0xffaa00 }) // 光源無視
            );
            b.visible = false;
            b.userData = { active: false, distance: 0 };
            scene.add(b);
            bulletPool.push(b);
        }

        // --- 入力系 ---
        const keys = {};
        let isFiring = false, fireTimer = 0;
        let isSpacePressed = false;
        let isMousePressed = false;

        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                if (!isSpacePressed) fireTimer = 0;
                isSpacePressed = true;
                isFiring = true;
            }
        });
        window.addEventListener('keyup', e => {
            keys[e.code] = false;
            if (e.code === 'Space') {
                isSpacePressed = false;
                isFiring = false;
            }
        });
        window.addEventListener('mousedown', () => {
            if (!isMousePressed) fireTimer = 0;
            isMousePressed = true;
            isFiring = true;
        });
        window.addEventListener('mouseup', () => {
            isMousePressed = false;
            isFiring = false;
        });

        function updateUI() {
            const activeBullets = bulletPool.filter(b => b.userData.active).length;
            const enemyBases = bases.filter(b => !b.userData.isPlayer && b.userData.active).length;
            document.getElementById('ui').innerHTML =
                `MISSION: ${enemyBases} BASES LEFT<br>PLAYER HP: ${Math.max(0, Math.floor(playerHP))}<br>AMMO: ${SIMULTANEOUS_BULLETS - activeBullets}/${SIMULTANEOUS_BULLETS}`;
        }

        // --- メインループ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 移動・旋回
            let turn = (keys['ArrowLeft'] || keys['KeyA'] ? TURN_SPEED : 0) + (keys['ArrowRight'] || keys['KeyD'] ? -TURN_SPEED : 0);
            shipGroup.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), turn));
            shipGroup.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), FORWARD_SPEED));
            shipGroup.position.copy(new THREE.Vector3(0, PLANET_RADIUS + ALTITUDE, 0)).applyQuaternion(shipGroup.quaternion);

            // 2. 弾丸更新
            const activeCount = bulletPool.filter(b => b.userData.active).length;
            bulletPool.forEach(b => {
                if (!b.userData.active) return;
                b.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), BULLET_SPEED));
                b.position.copy(new THREE.Vector3(0, PLANET_RADIUS + ALTITUDE, 0)).applyQuaternion(b.quaternion);

                // 当たり判定
                bases.forEach(base => {
                    if (base.userData.active && !base.userData.dying && !base.userData.isPlayer) {
                        if (b.position.distanceTo(base.position) < BASE_RADIUS + 2) {
                            base.userData.hp--;
                            b.userData.active = false; b.visible = false;
                            spawnParticles(b.position, 0xffaa00, 6, 0.6, 20); // 火花

                            if (base.userData.hp <= 0) {
                                base.userData.dying = true;
                                spawnRing(base.position, 0xffaa00); // 破壊時に輪っかを発生
                            }
                            updateUI();
                        }
                    }
                });

                b.userData.distance += BULLET_SPEED;
                if (b.userData.distance > Math.PI) { b.userData.active = false; b.visible = false; updateUI(); }
            });

            // 3. 基地演出 & 衝突
            bases.forEach(base => {
                if (base.userData.dying) {
                    base.userData.sink += 0.05;
                    base.material.color.lerp(new THREE.Color(0x000000), 0.05);

                    const shake = new THREE.Vector3((Math.random() - 0.5), 0, (Math.random() - 0.5)).multiplyScalar(0.3);
                    base.position.copy(base.userData.origin).add(shake).sub(base.userData.normal.clone().multiplyScalar(base.userData.sink));

                    if (Math.random() > 0.8) spawnParticles(base.position, 0x888888, 1, 0.1, 40); // 煙
                    if (base.userData.sink > BASE_HEIGHT) { base.userData.active = false; base.visible = false; updateUI(); }
                }
                if (base.userData.active && !base.userData.dying && shipGroup.position.distanceTo(base.position) < BASE_RADIUS + 2) {
                    playerHP -= 0.1;
                    updateUI();
                }
            });

            // 4. パーティクル更新（寿命が来たら完全に削除する）
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.vel);
                p.life--;
                if (p.life <= 0) {
                    p.mesh.visible = false; // 画面に出さない
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose(); // メモリから破棄
                    p.mesh.material.dispose();
                    particles.splice(i, 1);
                }
            }

            // 5. 輪っかエフェクト更新
            for (let i = rings.length - 1; i >= 0; i--) {
                const r = rings[i];
                r.scale += 0.2; // 広がる速度
                r.opacity -= 0.03; // 薄くなる速度
                r.mesh.scale.set(r.scale, r.scale, r.scale);
                r.mesh.material.opacity = Math.max(0, r.opacity);

                if (r.opacity <= 0) {
                    r.mesh.visible = false;
                    scene.remove(r.mesh);
                    r.mesh.geometry.dispose();
                    r.mesh.material.dispose();
                    rings.splice(i, 1);
                }
            }

            // 6. 連射制御
            if (isFiring && fireTimer <= 0 && activeCount < SIMULTANEOUS_BULLETS) {
                const b = bulletPool.find(b => !b.userData.active);
                if (b) {
                    b.visible = true; b.userData.active = true; b.userData.distance = 0;
                    b.quaternion.copy(shipGroup.quaternion);
                    updateUI();
                }
                fireTimer = 32; // 間隔を32フレームに設定
            }
            fireTimer--;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>