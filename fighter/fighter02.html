<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>3D Planet Fighter - Advanced Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffcc00;
            font-family: 'Courier New', Courier, monospace;
            font-size: 20px;
            pointer-events: none;
            text-shadow: 2px 2px 4px #000;
        }
    </style>
</head>

<body>
    <div id="ui">MISSION: DESTROY RED BASES<br>PLAYER HP: 100<br>AMMO: 4/4</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ゲーム定数 ---
        const PLANET_RADIUS = 50;
        const SHIP_SIZE = 3.75; // 5の75%に縮小
        const ALTITUDE = 5;
        const BASE_RADIUS = 3;
        const BASE_HEIGHT = 10;
        const MAX_POOL_BULLETS = 8;
        const SIMULTANEOUS_BULLETS = 4;

        // 速度を1/3に変更
        const FORWARD_SPEED = 0.005 / 3;
        const TURN_SPEED = 0.008;
        const BULLET_SPEED = 0.02 / 3;

        let playerHP = 100;
        let bases = [];
        let particles = [];
        let score = 0;

        // --- シーン・カメラ・レンダラー ---
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ライト
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 100, 50);
        scene.add(sunLight);

        // --- 惑星テクスチャ生成 (バリューノイズによる大陸と海の表現) ---
        function createAdvancedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(canvas.width, canvas.height);

            // 簡易的な乱数生成
            const random = (ix, iy) => {
                const dot = ix * 12.9898 + iy * 78.233;
                const r = (Math.sin(dot) * 43758.5453) % 1;
                return r < 0 ? r + 1 : r;
            };

            // 滑らかなバリューノイズ
            const valueNoise = (x, y) => {
                const ix = Math.floor(x);
                const iy = Math.floor(y);
                const fx = x - ix;
                const fy = y - iy;

                const sx = fx * fx * (3 - 2 * fx);
                const sy = fy * fy * (3 - 2 * fy);

                const v00 = random(ix, iy);
                const v10 = random(ix + 1, iy);
                const v01 = random(ix, iy + 1);
                const v11 = random(ix + 1, iy + 1);

                const nx0 = v00 + sx * (v10 - v00);
                const nx1 = v01 + sx * (v11 - v01);
                return nx0 + sy * (nx1 - nx0);
            };

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    let n = 0;
                    let amplitude = 1;
                    let frequency = 0.015; // ここを調整すると大陸の大きさが変わります
                    let maxValue = 0;

                    // 複数のノイズを重ねて自然な地形を作る
                    for (let i = 0; i < 5; i++) {
                        n += valueNoise(x * frequency, y * frequency) * amplitude;
                        maxValue += amplitude;
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    n = n / maxValue; // 0.0 ~ 1.0 に正規化

                    // 閾値で海と陸を分ける (0.52を境にする)
                    const isLand = n > 0.52;

                    let r, g, b;
                    if (isLand) {
                        // 陸地 (茶色〜緑のグラデーション)
                        const height = (n - 0.52) / 0.48;
                        r = 120 + height * 40;
                        g = 90 + height * 50;
                        b = 50 + height * 20;
                    } else {
                        // 海 (青のグラデーション)
                        const depth = n / 0.52;
                        r = 10 + depth * 30;
                        g = 50 + depth * 50;
                        b = 130 + depth * 80;
                    }

                    // 極地の白グラデーション
                    const distToPole = Math.min(y, canvas.height - y);
                    if (distToPole < 40) {
                        const lerp = 1 - (distToPole / 40);
                        r = r + (255 - r) * lerp;
                        g = g + (255 - g) * lerp;
                        b = b + (255 - b) * lerp;
                    }

                    const idx = (x + y * canvas.width) * 4;
                    imgData.data[idx] = r;
                    imgData.data[idx + 1] = g;
                    imgData.data[idx + 2] = b;
                    imgData.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
            return new THREE.CanvasTexture(canvas);
        }

        const planet = new THREE.Mesh(
            new THREE.SphereGeometry(PLANET_RADIUS, 64, 48),
            new THREE.MeshStandardMaterial({ map: createAdvancedTexture(), roughness: 0.8 })
        );
        scene.add(planet);

        // --- 戦闘機 (サイズ75%に縮小) ---
        const shipGroup = new THREE.Group();
        const shipMesh = new THREE.Mesh(
            // 半径を2から1.5に縮小
            new THREE.ConeGeometry(1.5, SHIP_SIZE, 5).rotateX(Math.PI / 2),
            new THREE.MeshStandardMaterial({ color: 0xffcc00, flatShading: true })
        );
        shipGroup.add(shipMesh);
        shipGroup.position.set(0, PLANET_RADIUS + ALTITUDE, 0);
        scene.add(shipGroup);

        // --- カメラ ---
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 0);
        camera.up.set(0, 0, 1);
        camera.lookAt(0, 0, 0);
        shipGroup.add(camera);

        // --- エフェクト関数 ---
        function spawnParticles(pos, color, count, speed, life) {
            for (let i = 0; i < count; i++) {
                const p = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 4, 4),
                    new THREE.MeshBasicMaterial({ color: color })
                );
                p.position.copy(pos);
                particles.push({
                    mesh: p,
                    vel: new THREE.Vector3((Math.random() - 0.5) * speed, (Math.random() - 0.5) * speed, (Math.random() - 0.5) * speed),
                    life: life
                });
                scene.add(p);
            }
        }

        // --- 敵基地作成 ---
        function createBases() {
            for (let i = 0; i < 4; i++) {
                const isPlayer = (i === 0);
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(BASE_RADIUS, BASE_RADIUS, BASE_HEIGHT, 8),
                    new THREE.MeshStandardMaterial({ color: isPlayer ? 0xffcc00 : 0xff4444, flatShading: true })
                );

                let pos;
                do {
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = 2 * Math.PI * Math.random();
                    pos = new THREE.Vector3().setFromSphericalCoords(PLANET_RADIUS, phi, theta);
                } while (pos.distanceTo(shipGroup.position) < 30);

                base.position.copy(pos);
                const normal = pos.clone().normalize();
                base.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
                base.position.add(normal.clone().multiplyScalar(BASE_HEIGHT / 2));

                base.userData = {
                    hp: 8, active: true, dying: false, isPlayer,
                    normal, origin: base.position.clone(), sink: 0
                };
                scene.add(base);
                bases.push(base);
            }
        }
        createBases();

        // --- 弾丸プール (サイズ75%に縮小) ---
        const bulletPool = [];
        for (let i = 0; i < MAX_POOL_BULLETS; i++) {
            // 半径を0.6から0.45に縮小
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.45, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
            b.visible = false;
            b.userData = { active: false, distance: 0 };
            scene.add(b);
            bulletPool.push(b);
        }

        // --- 入力系 ---
        const keys = {};
        let isFiring = false, fireTimer = 0;
        window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Space') isFiring = true; });
        window.addEventListener('keyup', e => { keys[e.code] = false; if (e.code === 'Space') isFiring = false; });
        window.addEventListener('mousedown', () => isFiring = true);
        window.addEventListener('mouseup', () => isFiring = false);

        function updateUI() {
            const activeBullets = bulletPool.filter(b => b.userData.active).length;
            const enemyBases = bases.filter(b => !b.userData.isPlayer && b.userData.active).length;
            document.getElementById('ui').innerHTML =
                `MISSION: ${enemyBases} BASES LEFT<br>PLAYER HP: ${Math.max(0, Math.floor(playerHP))}<br>AMMO: ${SIMULTANEOUS_BULLETS - activeBullets}/${SIMULTANEOUS_BULLETS}`;
        }

        // --- メインループ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 移動・旋回
            let turn = (keys['ArrowLeft'] || keys['KeyA'] ? TURN_SPEED : 0) + (keys['ArrowRight'] || keys['KeyD'] ? -TURN_SPEED : 0);
            shipGroup.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), turn));
            shipGroup.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), FORWARD_SPEED));
            shipGroup.position.copy(new THREE.Vector3(0, PLANET_RADIUS + ALTITUDE, 0)).applyQuaternion(shipGroup.quaternion);

            // 2. 弾丸更新
            const activeCount = bulletPool.filter(b => b.userData.active).length;
            bulletPool.forEach(b => {
                if (!b.userData.active) return;
                b.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), BULLET_SPEED));
                b.position.copy(new THREE.Vector3(0, PLANET_RADIUS + ALTITUDE, 0)).applyQuaternion(b.quaternion);

                // 当たり判定
                bases.forEach(base => {
                    if (base.userData.active && !base.userData.dying && !base.userData.isPlayer) {
                        if (b.position.distanceTo(base.position) < BASE_RADIUS + 2) {
                            base.userData.hp--;
                            b.userData.active = false; b.visible = false;
                            spawnParticles(b.position, 0xffaa00, 6, 0.6, 20); // 火花
                            if (base.userData.hp <= 0) base.userData.dying = true;
                            updateUI();
                        }
                    }
                });

                b.userData.distance += BULLET_SPEED;
                if (b.userData.distance > Math.PI) { b.userData.active = false; b.visible = false; updateUI(); }
            });

            // 3. 基地演出 & 衝突
            bases.forEach(base => {
                if (base.userData.dying) {
                    base.userData.sink += 0.05;
                    const shake = new THREE.Vector3((Math.random() - 0.5), 0, (Math.random() - 0.5)).multiplyScalar(0.3);
                    base.position.copy(base.userData.origin).add(shake).sub(base.userData.normal.clone().multiplyScalar(base.userData.sink));
                    if (Math.random() > 0.8) spawnParticles(base.position, 0x888888, 1, 0.1, 40); // 煙
                    if (base.userData.sink > BASE_HEIGHT) { base.userData.active = false; base.visible = false; updateUI(); }
                }
                if (base.userData.active && !base.userData.dying && shipGroup.position.distanceTo(base.position) < BASE_RADIUS + 2) {
                    playerHP -= 0.1;
                    updateUI();
                }
            });

            // 4. パーティクル更新
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.vel);
                p.life--;
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }

            // 5. 連射制御
            if (isFiring && fireTimer <= 0 && activeCount < SIMULTANEOUS_BULLETS) {
                const b = bulletPool.find(b => !b.userData.active);
                if (b) {
                    b.visible = true; b.userData.active = true; b.userData.distance = 0;
                    b.quaternion.copy(shipGroup.quaternion);
                    updateUI();
                }
                fireTimer = 12;
            }
            fireTimer--;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>