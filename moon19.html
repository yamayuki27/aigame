<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Survival - UI Refined</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script>
        let player, bases = [], crystals = [], enemies = [], wanderers = [], bullets = [], drops = [], turrets = [], particles = [], bosses = [], stakes = [], generators = [];
        let baseStock = { c: 0, fe: 0 };
        let deathDrop = null, laserLevel = 1;
        let upgradeLevels, lastBaseTouched, lastMoveDir, nextBaseCandidates = [];
        let worldSize = 4000, goal = { x: 3800, y: 3800 };
        let gameState = "START", requiredFeForBase = 16, buildProgress = 0;
        let isRespawning = false, respawnTimer = 0;
        let damageTexts = [];
        let candidateAlert = { txt: "", life: 0 };

        const ROPE_SEGMENTS = 90, SEGMENT_LEN = 11, MAX_ROPE_DIST = ROPE_SEGMENTS * SEGMENT_LEN;
        let ropePoints = [], inputStartPos = null, isInputActive = false;
        let currentRopeLenDisplay = 0;

        const COL_C = [255, 190, 50], COL_FE = [180, 180, 200];

        function setup() {
            createCanvas(windowWidth, windowHeight);
            initGame();
        }

        function windowResized() { resizeCanvas(windowWidth, windowHeight); }

        function initGame() {
            player = { x: 2000, y: 2000, ox: 50, c: 0, fe: 0 };
            baseStock = { c: 0, fe: 0 }; deathDrop = null; laserLevel = 1;
            upgradeLevels = { laser: 1, speed: 2.3 };
            stakes = [];
            for (let i = 0; i < 240; i++) spawnStake();
            let bx = 1950, by = 1950;
            while (isNearObject(bx, by, 80)) { bx += 50; by += 50; }
            bases = [{ x: bx, y: by }];
            lastBaseTouched = bases[0];
            player.x = bx + 10; player.y = by + 10;
            lastMoveDir = { x: 1, y: 0 };
            crystals = []; enemies = []; wanderers = []; bullets = []; drops = []; turrets = []; particles = []; bosses = []; generators = [];
            damageTexts = [];
            requiredFeForBase = 16; buildProgress = 0;
            for (let i = 0; i < 16; i++) spawnGenerator();
            for (let j = 0; j < 600; j++) {
                let x = random(worldSize), y = random(worldSize);
                if (getTerrain(x, y) < 0.6 && !isNearObject(x, y, 30)) crystals.push({ x, y });
            }
            for (let i = 0; i < 12; i++) spawnBoss();
            for (let i = 0; i < 24; i++) spawnTurret();
            for (let i = 0; i < 50; i++) spawnWanderer();
            initRopeCoil();
        }

        function isNearObject(x, y, distThresh) {
            for (let s of stakes) if (dist(x, y, s.x, s.y) < distThresh) return true;
            for (let b of bases) if (dist(x, y, b.x, b.y) < distThresh + 40) return true;
            return false;
        }

        function initRopeCoil() {
            ropePoints = [];
            for (let i = 0; i <= ROPE_SEGMENTS; i++) {
                ropePoints.push({ x: lastBaseTouched.x, y: lastBaseTouched.y, oldX: lastBaseTouched.x, oldY: lastBaseTouched.y });
            }
        }

        function draw() {
            if (gameState === "START") { drawScreen("SPACE SURVIVAL", "TAP TO START"); return; }
            runGameLoop();
        }

        function drawScreen(title, sub) {
            background(0); textAlign(CENTER); fill(255);
            textSize(32); text(title, width / 2, height / 2 - 20);
            textSize(16); text(sub, width / 2, height / 2 + 30);
        }

        function runGameLoop() {
            background(15);
            updateLogic();
            push();
            translate(width / 2 - player.x, height / 2 - player.y);
            drawTerrain();
            drawRope();
            drawObjects();

            push(); translate(player.x, player.y); rotate(atan2(lastMoveDir.y, lastMoveDir.x));
            if (isRespawning && frameCount % 4 < 2) fill(255, 0, 0);
            else { fill(0); stroke(0, 255, 0); strokeWeight(2); }
            beginShape(); vertex(12, 0); vertex(-6, 8); vertex(-10, 5); vertex(-10, -5); vertex(-6, -8); endShape(CLOSE);
            pop();

            drawDamageTexts();
            pop();

            drawUI();
            drawMiniMap();
            if (isInputActive && inputStartPos) drawInputUI();
        }

        function updateLogic() {
            if (isRespawning) {
                respawnTimer++;
                let speed = 0.15 + (respawnTimer * 0.005);
                for (let i = 0; i < ropePoints.length - 1; i++) {
                    ropePoints[i + 1].x = lerp(ropePoints[i + 1].x, ropePoints[i].x, speed);
                    ropePoints[i + 1].y = lerp(ropePoints[i + 1].y, ropePoints[i].y, speed);
                }
                player.x = ropePoints[ROPE_SEGMENTS].x; player.y = ropePoints[ROPE_SEGMENTS].y;
                if (respawnTimer > 70 || dist(player.x, player.y, lastBaseTouched.x, lastBaseTouched.y) < 10) {
                    isRespawning = false; player.x = lastBaseTouched.x; player.y = lastBaseTouched.y; player.ox = 50; initRopeCoil();
                }
                return;
            }

            let nextX = player.x, nextY = player.y;
            if (isInputActive && inputStartPos) {
                let dx = mouseX - inputStartPos.x, dy = mouseY - inputStartPos.y, d = sqrt(dx * dx + dy * dy);
                if (d > 5) {
                    let spd = map(d, 0, 100, 0, upgradeLevels.speed, true);
                    let angle = atan2(dy, dx);
                    nextX += cos(angle) * spd; nextY += sin(angle) * spd;
                    lastMoveDir = { x: cos(angle) * 14, y: sin(angle) * 14 };
                }
                if (frameCount % 12 === 0) fireLaser();
            }

            let totalLen = 0;
            for (let i = 0; i < ROPE_SEGMENTS - 1; i++) totalLen += dist(ropePoints[i].x, ropePoints[i].y, ropePoints[i + 1].x, ropePoints[i + 1].y);
            let lastSegmentLen = dist(ropePoints[ROPE_SEGMENTS - 1].x, ropePoints[ROPE_SEGMENTS - 1].y, nextX, nextY);
            if (totalLen + lastSegmentLen > MAX_ROPE_DIST) {
                let allowed = max(0, MAX_ROPE_DIST - totalLen);
                let ang = atan2(nextY - ropePoints[ROPE_SEGMENTS - 1].y, nextX - ropePoints[ROPE_SEGMENTS - 1].x);
                nextX = ropePoints[ROPE_SEGMENTS - 1].x + cos(ang) * allowed;
                nextY = ropePoints[ROPE_SEGMENTS - 1].y + sin(ang) * allowed;
            }
            currentRopeLenDisplay = totalLen + lastSegmentLen;

            if (getTerrain(nextX, nextY) < 0.6) { player.x = nextX; player.y = nextY; }
            player.ox -= 0.012;

            updateRopePhysics();

            bases.forEach(b => {
                if (dist(player.x, player.y, b.x, b.y) < 70) {
                    if (lastBaseTouched !== b) { lastBaseTouched = b; initRopeCoil(); }
                    player.ox = 50; baseStock.c += player.c; player.c = 0; baseStock.fe += player.fe; player.fe = 0;
                    let cost = laserLevel * 6; if (baseStock.c >= cost && laserLevel < 8) { baseStock.c -= cost; laserLevel++; }
                }
            });

            if (deathDrop && dist(player.x, player.y, deathDrop.x, deathDrop.y) < 35) { player.c += deathDrop.c; player.fe += deathDrop.fe; deathDrop = null; }

            processProjectiles();
            processEnemies();
            processGenerators();
            processCrystals();
            updateDamageTexts();
            if (baseStock.fe >= requiredFeForBase && nextBaseCandidates.length === 0) spawnCandidates();

            let nearCandidate = false;
            nextBaseCandidates.forEach(c => {
                if (dist(player.x, player.y, c.x, c.y) < 55) {
                    nearCandidate = true;
                    buildProgress += 0.75;
                    if (buildProgress > 100) {
                        bases.push({ x: c.x, y: c.y });
                        baseStock.fe -= requiredFeForBase; requiredFeForBase += 4; buildProgress = 0; nextBaseCandidates = [];
                    }
                }
            });
            if (!nearCandidate) buildProgress = 0;
            if (candidateAlert.life > 0) candidateAlert.life--;
        }

        function updateRopePhysics() {
            if (isRespawning) return;
            ropePoints[0].x = lastBaseTouched.x; ropePoints[0].y = lastBaseTouched.y;
            ropePoints[ROPE_SEGMENTS].x = player.x; ropePoints[ROPE_SEGMENTS].y = player.y;
            for (let i = 1; i < ROPE_SEGMENTS; i++) {
                let p = ropePoints[i];
                let vx = (p.x - p.oldX) * 0.93; let vy = (p.y - p.oldY) * 0.93;
                p.oldX = p.x; p.oldY = p.y;
                vx += (lastBaseTouched.x - p.x) * 0.0003; vy += (lastBaseTouched.y - p.y) * 0.0003;
                p.x += vx; p.y += vy;
                if (getTerrain(p.x, p.y) >= 0.6) { p.x = p.oldX; p.y = p.oldY; }
            }
            for (let n = 0; n < 18; n++) {
                for (let i = 0; i < ROPE_SEGMENTS; i++) {
                    let p1 = ropePoints[i], p2 = ropePoints[i + 1];
                    for (let s of stakes) {
                        let d = distToSegment(s.x, s.y, p1.x, p1.y, p2.x, p2.y);
                        if (d < 18) {
                            let ang = atan2((p1.y + p2.y) / 2 - s.y, (p1.x + p2.x) / 2 - s.x);
                            let push = (18 - d) * 0.5;
                            if (i > 0) { p1.x += cos(ang) * push; p1.y += sin(ang) * push; }
                            if (i + 1 < ROPE_SEGMENTS) { p2.x += cos(ang) * push; p2.y += sin(ang) * push; }
                        }
                    }
                    let dx = p2.x - p1.x, dy = p2.y - p1.y, d = sqrt(dx * dx + dy * dy);
                    if (d > SEGMENT_LEN) {
                        let diff = (d - SEGMENT_LEN) / d;
                        let m1 = (i === 0) ? 0 : 0.5; let m2 = (i + 1 === ROPE_SEGMENTS) ? 0 : 0.5;
                        p1.x += dx * diff * m1; p1.y += dy * diff * m1;
                        p2.x -= dx * diff * m2; p2.y -= dy * diff * m2;
                    }
                }
            }
        }

        function processProjectiles() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i]; b.x += b.vx; b.y += b.vy; b.life--;
                if (b.isEnemy) { for (let bs of bases) { if (dist(b.x, b.y, bs.x, bs.y) < 80) { b.life = 0; break; } } }
                let hitSomething = false;
                for (let s of stakes) {
                    if (dist(b.x, b.y, s.x, s.y) < 16) {
                        s.hp -= (b.lvl >= 5 ? 2 : 1);
                        spawnSpark(b.x, b.y);
                        damageTexts.push({ x: s.x, y: s.y - 20, txt: `${max(0, s.hp)}/20`, life: 15 });
                        if (b.reflects > 0) {
                            let n = createVector(b.x - s.x, b.y - s.y).normalize();
                            let v = createVector(b.vx, b.vy); v.sub(n.mult(2 * v.dot(n))); b.vx = v.x; b.vy = v.y; b.reflects--;
                        } else hitSomething = true;
                        if (s.hp <= 0) { for (let j = 0; j < 2; j++) drops.push({ x: s.x, y: s.y, type: 'Fe' }); stakes = stakes.filter(x => x !== s); }
                        break;
                    }
                }
                if (!hitSomething && getTerrain(b.x, b.y) >= 0.6) {
                    spawnSpark(b.x, b.y, [255, 255, 255]);
                    if (b.reflects > 0) {
                        if (getTerrain(b.x - b.vx, b.y) < 0.6) b.vx *= -1; else if (getTerrain(b.x, b.y - b.vy) < 0.6) b.vy *= -1; else { b.vx *= -1; b.vy *= -1; }
                        b.reflects--;
                    } else hitSomething = true;
                }
                if (!b.isEnemy) {
                    let targets = [...enemies, ...wanderers, ...turrets, ...bosses, ...generators];
                    for (let t of targets) {
                        let hitDist = t.isBoss ? 45 : (t.isGenerator ? 30 : 18);
                        if (dist(b.x, b.y, t.x, t.y) < hitDist && !b.hitIds.includes(t)) {
                            t.hp -= (b.lvl >= 5 ? 2 : 1);
                            spawnSpark(b.x, b.y, t.isBoss ? [255, 50, 50] : [255, 255, 255]);
                            let maxHp = t.isBoss ? 30 : (t.isGenerator ? 32 : (t.isTurret ? 8 : (t.isWanderer ? 4 : 1)));
                            if (maxHp >= 4 || t.hp > 2) damageTexts.push({ x: t.x, y: t.y - 20, txt: `${max(0, t.hp)}/${maxHp}`, life: 15 });
                            if (b.lvl < 5) b.life = 0; else b.hitIds.push(t);
                            if (t.hp <= 0) handleTargetDeath(t);
                            break;
                        }
                    }
                } else if (dist(b.x, b.y, player.x, player.y) < 12) { triggerRespawn(); b.life = 0; }
                if (hitSomething || b.life <= 0) bullets.splice(i, 1);
            }
            for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); }
        }

        function handleTargetDeath(t) {
            if (t.isGenerator) { for (let j = 0; j < 12; j++) drops.push({ x: t.x + random(-20, 20), y: t.y + random(-20, 20), type: 'Fe' }); generators = generators.filter(x => x !== t); }
            else if (t.isBoss) { for (let j = 0; j < 16; j++) drops.push({ x: t.x + random(-30, 30), y: t.y + random(-30, 30), type: 'Fe' }); bosses = bosses.filter(x => x !== t); }
            else if (t.isTurret) { for (let j = 0; j < 4; j++) drops.push({ x: t.x, y: t.y, type: 'Fe' }); turrets = turrets.filter(x => x !== t); }
            else if (t.isWanderer) { drops.push({ x: t.x, y: t.y, type: 'Fe' }); wanderers = wanderers.filter(x => x !== t); }
            else { drops.push({ x: t.x, y: t.y, type: 'Fe' }); enemies = enemies.filter(x => x !== t); }
        }

        function processEnemies() {
            [...bosses, ...enemies, ...wanderers].forEach(e => {
                let px = e.x, py = e.y;
                if (e.isBoss) {
                    e.rot += 0.24; let d = dist(player.x, player.y, e.x, e.y);
                    if (d < 500 && d > 250) { e.x += (player.x - e.x) * 0.0017; e.y += (player.y - e.y) * 0.0017; }
                    let cycle = frameCount % 120;
                    if (d < 600 && cycle < 60 && cycle % 35 === 0) {
                        for (let i = 0; i < 8; i++) { let a = e.rot + (TWO_PI / 8) * i; bullets.push({ x: e.x, y: e.y, vx: cos(a) * 1.5, vy: sin(a) * 1.5, isEnemy: true, life: 720, lvl: 1, hitIds: [] }); }
                    }
                } else if (e.isWanderer) { e.a += 0.03; e.x += cos(e.a) * 2; e.y += sin(e.a) * 2; if (dist(player.x, player.y, e.x, e.y) < 20) triggerRespawn(); }
                else { let d = dist(player.x, player.y, e.x, e.y); if (d < 600) { let a = atan2(player.y - e.y, player.x - e.x); e.x += cos(a) * 0.55; e.y += sin(a) * 0.55; } if (d < 15) triggerRespawn(); }
                if (getTerrain(e.x, e.y) >= 0.6) { e.x = px; e.y = py; }
                for (let bs of bases) if (dist(e.x, e.y, bs.x, bs.y) < 80) { let ang = atan2(e.y - bs.y, e.x - bs.x); e.x = bs.x + cos(ang) * 80; e.y = bs.y + sin(ang) * 80; }
            });
            turrets.forEach(t => {
                let targetAngle = atan2(player.y - t.y, player.x - t.x);
                let diff = targetAngle - t.angle; while (diff < -PI) diff += TWO_PI; while (diff > PI) diff -= TWO_PI;
                t.angle += diff * 0.02;
                if (dist(player.x, player.y, t.x, t.y) < 400 && frameCount % 100 === 0) bullets.push({ x: t.x, y: t.y, vx: cos(t.angle) * 1.5, vy: sin(t.angle) * 1.5, isEnemy: true, life: 600, lvl: 1, hitIds: [] });
            });
            generators.forEach(g => { if (dist(player.x, player.y, g.x, g.y) < 25) triggerRespawn(); });
        }

        function getTerrain(x, y) { return noise(floor(x / 50) * 0.05, floor(y / 50) * 0.05); }

        function drawTerrain() {
            noStroke(); fill(40);
            let sX = floor((player.x - width / 2) / 50) * 50, sY = floor((player.y - height / 2) / 50) * 50;
            for (let x = sX; x < sX + width + 100; x += 50) for (let y = sY; y < sY + height + 100; y += 50) if (getTerrain(x, y) >= 0.6) rect(x, y, 51, 51);
        }

        function fireLaser() {
            let myBullets = bullets.filter(b => !b.isEnemy).length;
            if (myBullets < (laserLevel <= 4 ? laserLevel : 4)) {
                let ang = atan2(lastMoveDir.y, lastMoveDir.x);
                bullets.push({ x: player.x, y: player.y, vx: cos(ang) * 12, vy: sin(ang) * 12, isEnemy: false, life: 60, lvl: laserLevel, hitIds: [], reflects: (laserLevel >= 7 ? 3 : 0), col: laserLevel >= 4 ? [0, 255, 255] : [255, 255, 0] });
            }
        }

        function processGenerators() { generators.forEach(g => { if (dist(player.x, player.y, g.x, g.y) < 800) { if (enemies.filter(e => e.genId === g.id).length < 4 && frameCount % 180 === 0) enemies.push({ x: g.x, y: g.y, hp: 1, genId: g.id }); } }); }
        function spawnSpark(x, y, col) { for (let k = 0; k < 5; k++) particles.push({ x, y, vx: random(-4, 4), vy: random(-4, 4), life: 15, col: col || [255, 200, 50] }); }
        function processCrystals() {
            for (let i = crystals.length - 1; i >= 0; i--) if (dist(player.x, player.y, crystals[i].x, crystals[i].y) < 25) { player.c++; crystals.splice(i, 1); }
            for (let i = drops.length - 1; i >= 0; i--) if (dist(player.x, player.y, drops[i].x, drops[i].y) < 25) { if (drops[i].type === 'C') player.c++; else player.fe++; drops.splice(i, 1); }
        }

        function drawRope() {
            let currentRopeLen = 0;
            for (let i = 0; i < ropePoints.length - 1; i++) currentRopeLen += dist(ropePoints[i].x, ropePoints[i].y, ropePoints[i + 1].x, ropePoints[i + 1].y);
            let tension = map(currentRopeLen, MAX_ROPE_DIST * 0.8, MAX_ROPE_DIST, 0, 1, true);
            for (let i = 0; i < ropePoints.length; i++) if (i % 6 === 0) { fill(255, 150); noStroke(); ellipse(ropePoints[i].x, ropePoints[i].y, 3); }
            noFill(); stroke(lerpColor(color(100, 200, 255, 100), color(255, 50, 50, 150), tension)); strokeWeight(2); beginShape(); for (let p of ropePoints) curveVertex(p.x, p.y); endShape();
        }

        function drawObjects() {
            fill(0, 255, 200); stroke(255); rect(goal.x - 15, goal.y - 40, 30, 40);
            bases.forEach(b => { stroke(100, 150, 255); noFill(); strokeWeight(2.5); rect(b.x - 40, b.y - 40, 80, 80); stroke(100, 150, 255, 50); ellipse(b.x, b.y, 150); });
            nextBaseCandidates.forEach(c => {
                stroke(255, 255, 0, 150); strokeWeight(2); noFill(); ellipse(c.x, c.y, 50);
                if (dist(player.x, player.y, c.x, c.y) < 55 && buildProgress > 0) {
                    noStroke(); fill(50, 150); rect(c.x - 50, c.y - 45, 100, 8);
                    fill(255, 255, 0); rect(c.x - 50, c.y - 45, buildProgress, 8);
                }
            });
            textSize(14); textAlign(CENTER); noStroke();
            crystals.forEach(c => { fill(COL_C); text("C", c.x, c.y); });
            drops.forEach(d => { fill(d.type === 'C' ? COL_C : COL_FE); text(d.type, d.x, d.y); });
            enemies.forEach(e => { fill(255, 0, 0); ellipse(e.x, e.y, 10); });
            wanderers.forEach(w => { fill(200, 0, 50); ellipse(w.x, w.y, 22); });
            turrets.forEach(t => { push(); translate(t.x, t.y); rotate(t.angle); fill(100); rect(-15, -15, 30, 30); fill(255, 50, 0); rect(0, -5, 20, 10); pop(); });
            bosses.forEach(b => { push(); translate(b.x, b.y); rotate(b.rot); fill(200, 0, 0); stroke(255, 100); strokeWeight(2); rect(-30, -30, 60, 60); pop(); });
            stakes.forEach(s => { fill(60); stroke(100); rect(s.x - 12, s.y - 12, 24, 24); });
            generators.forEach(g => { let act = dist(player.x, player.y, g.x, g.y) < 800; fill(act ? [150, 0, 255] : [70, 0, 100]); stroke(255, 100); rect(g.x - 20, g.y - 20, 40, 40); });
            bullets.forEach(b => { stroke(b.isEnemy ? [255, 120, 0] : b.col); strokeWeight(b.isEnemy ? 3 : 2); line(b.x, b.y, b.x - b.vx * 0.8, b.y - b.vy * 0.8); });
            if (deathDrop) { stroke(255, 0, 0); strokeWeight(4); line(deathDrop.x - 15, deathDrop.y - 15, deathDrop.x + 15, deathDrop.y + 15); line(deathDrop.x + 15, deathDrop.y - 15, deathDrop.x - 15, deathDrop.y + 15); }
            for (let p of particles) { noStroke(); fill(p.col[0], p.col[1], p.col[2], map(p.life, 0, 15, 0, 255)); ellipse(p.x, p.y, 3); }
        }

        function drawMiniMap() {
            let ms = 110, mx = width - ms - 20, my = 20; fill(0, 180); stroke(255, 50); rect(mx, my, ms, ms);
            let sc = ms / worldSize; push(); translate(mx, my); noStroke(); fill(120); stakes.forEach(s => ellipse(s.x * sc, s.y * sc, 1.5));
            fill(255, 0, 0); bosses.forEach(b => rect(b.x * sc - 2, b.y * sc - 2, 4, 4));
            stroke(255, 255, 0); noFill(); nextBaseCandidates.forEach(c => ellipse(c.x * sc, c.y * sc, 3));
            noStroke(); fill(0, 255, 0); ellipse(player.x * sc, player.y * sc, 4);
            stroke(100, 150, 255); noFill(); bases.forEach(b => rect(b.x * sc - 2, b.y * sc - 2, 4, 4)); pop();
        }

        function triggerRespawn() { if (!isRespawning) { deathDrop = { x: player.x, y: player.y, c: player.c, fe: player.fe }; isRespawning = true; respawnTimer = 0; player.c = 0; player.fe = 0; isInputActive = false; } }
        function drawInputUI() { noFill(); stroke(255, 50); ellipse(inputStartPos.x, inputStartPos.y, 60); line(inputStartPos.x, inputStartPos.y, mouseX, mouseY); }
        function mousePressed() { if (gameState === "START") { gameState = "PLAY"; return false; } isInputActive = true; inputStartPos = { x: mouseX, y: mouseY }; return false; }
        function mouseReleased() { isInputActive = false; return false; }
        function touchStarted() { return mousePressed(); }
        function touchEnded() { return mouseReleased(); }
        function distToSegment(px, py, x1, y1, x2, y2) {
            let l2 = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2); if (l2 == 0) return dist(px, py, x1, y1);
            let t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2));
            return dist(px, py, x1 + t * (x2 - x1), y1 + t * (y2 - y1));
        }
        function spawnStake() { let x = random(worldSize), y = random(worldSize); if (getTerrain(x, y) < 0.6) stakes.push({ x, y, hp: 20 }); else if (random() < 0.4) spawnStake(); }
        function spawnGenerator() { let x, y; do { x = random(worldSize); y = random(worldSize); } while (getTerrain(x, y) >= 0.6 || dist(x, y, 2000, 2000) < 400 || isNearObject(x, y, 80)); generators.push({ x, y, hp: 32, id: random(), isGenerator: true }); }
        function spawnTurret() { let x, y; do { x = random(worldSize); y = random(worldSize); } while (getTerrain(x, y) >= 0.6 || isNearObject(x, y, 60)); turrets.push({ x, y, hp: 8, angle: 0, isTurret: true }); }
        function spawnWanderer() { let x, y; do { x = random(worldSize); y = random(worldSize); } while (getTerrain(x, y) >= 0.6 || isNearObject(x, y, 50)); wanderers.push({ x, y, a: random(TWO_PI), hp: 4, isWanderer: true }); }
        function spawnBoss() { let x, y; do { x = random(worldSize); y = random(worldSize); } while (getTerrain(x, y) >= 0.6 || dist(x, y, 2000, 2000) < 800 || isNearObject(x, y, 80)); bosses.push({ x, y, hp: 30, isBoss: true, rot: 0 }); }

        function drawUI() {
            textAlign(LEFT); drawGauge(20, 35, "OX", player.ox, 50);
            fill(255); noStroke(); textSize(14);
            // BAG情報
            text(`[BAG] `, 20, 70); fill(COL_C); text(`C:${player.c}`, 70, 70); fill(COL_FE); text(`Fe:${player.fe}`, 120, 70);

            // LAZER UI 統合
            fill(0, 255, 255); text(`[LAZER] Level ${laserLevel} : C ${baseStock.c}/${laserLevel * 6}`, 20, 95);

            // BASE UI 統合 (Levelは拠点の数)
            fill(100, 200, 255); text(`[BASE] Level ${bases.length} : Fe ${baseStock.fe}/${requiredFeForBase}`, 20, 120);

            // ROPE UI
            fill(255, 255, 0); text(`[ROPE] ${floor(currentRopeLenDisplay)} / ${MAX_ROPE_DIST}`, 20, 145);

            if (candidateAlert.life > 0) {
                textAlign(CENTER); textSize(24); fill(255, 255, 0, map(candidateAlert.life, 0, 60, 0, 255));
                text("NEW BASE CANDIDATES LOCATED", width / 2, height / 2 - 100);
            }
        }
        function drawGauge(x, y, label, val, maxVal) { fill(50); rect(x + 30, y - 12, 100, 15); fill(val > 15 ? [0, 255, 0] : [255, 0, 0]); rect(x + 30, y - 12, (val / maxVal) * 100, 15); fill(255); text(label, x, y); }

        function spawnCandidates() {
            nextBaseCandidates = [];
            let startAngle = random(TWO_PI);
            for (let i = 0; i < 3; i++) {
                let a = startAngle + (TWO_PI / 3) * i + random(-0.5, 0.5);
                let r = MAX_ROPE_DIST * random(0.7, 0.9);
                let tx = lastBaseTouched.x + cos(a) * r, ty = lastBaseTouched.y + sin(a) * r;
                if (getTerrain(tx, ty) < 0.6 && !isNearObject(tx, ty, 80)) nextBaseCandidates.push({ x: tx, y: ty });
            }
            candidateAlert = { life: 60 };
        }
        function updateDamageTexts() { for (let i = damageTexts.length - 1; i >= 0; i--) { damageTexts[i].life--; if (damageTexts[i].life <= 0) damageTexts.splice(i, 1); } }
        function drawDamageTexts() { textAlign(CENTER); textSize(12); for (let d of damageTexts) { fill(255, map(d.life, 0, 15, 0, 255)); noStroke(); text(d.txt, d.x, d.y); } }
    </script>
</body>

</html>