<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Survival</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0f0f0f;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            /* スマホ操作用 */
        }

        canvas {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border-radius: 4px;
        }
    </style>
</head>

<body>

    <script>
        // ==========================================
        // ゲームロジック (Space Survival Complete)
        // ==========================================

        let player, bases = [], crystals = [], enemies = [], wanderers = [], bullets = [], drops = [], turrets = [], particles = [], bosses = [], stakes = [];
        let baseStock = { h: 0, o: 0, c: 0, fe: 0 };
        let deathDrop = null, laserLevel = 1;
        let upgradeLevels, lastBaseTouched, lastMoveDir, nextBaseCandidate;
        let worldSize = 4000, goal = { x: 3800, y: 3800 };
        let gameState = "START", requiredFeForBase = 16, buildProgress = 0;
        let isRespawning = false, respawnTimer = 0, respawnStartPos = { x: 0, y: 0 };

        // --- 物理ホース・操作用の変数 ---
        let inputStartPos = null, isInputActive = false;
        let ropePoints = [];
        const ROPE_SEGMENTS = 60;
        const SEGMENT_LEN = 11;
        const MAX_ROPE_DIST = ROPE_SEGMENTS * SEGMENT_LEN;

        function setup() {
            createCanvas(600, 480);
            // タッチ操作のスクロール防止
            let canvas = document.querySelector('canvas');
            canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
            canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            initGame();
        }

        function initGame() {
            // 燃料(fuel)は減らさないがデータとしては維持
            player = { x: 2000, y: 2000, ox: 50, fuel: 50, maxOx: 50, maxFuel: 50, hCount: 0, oCount: 0, h: 0, o: 0, c: 0, fe: 0 };
            baseStock = { h: 0, o: 0, c: 0, fe: 0 };
            deathDrop = null; laserLevel = 1;
            upgradeLevels = { laser: 1, speed: 1.5 };
            bases = [{ x: 1950, y: 1950 }];
            lastBaseTouched = bases[0];
            lastMoveDir = { x: 12, y: 0 };
            crystals = []; enemies = []; wanderers = []; bullets = []; drops = []; turrets = []; particles = []; bosses = []; stakes = [];
            requiredFeForBase = 16; buildProgress = 0; nextBaseCandidate = null;
            isRespawning = false;

            initRopeCoil();

            // オブジェクトの初期配置
            for (let i = 0; i < 450; i++) spawnCrystal();
            for (let i = 0; i < 4; i++) spawnBoss();
            for (let i = 0; i < 32; i++) spawnStake();
            spawnTurretsStrategically(16);
            for (let i = 0; i < 32; i++) spawnWanderer();
        }

        function spawnTurretsStrategically(count) {
            turrets = [];
            let attempts = 0;
            while (turrets.length < count && attempts < 1000) {
                attempts++;
                let x = random(worldSize), y = random(worldSize);
                let dToStart = dist(x, y, 2000, 2000);
                let valid = false;
                if (getTerrain(x, y) >= 0.6) continue;
                if (turrets.length === 0) {
                    if (dToStart > 400 && dToStart < 600) valid = true;
                } else {
                    if (dToStart > 800) {
                        let tooClose = false;
                        for (let t of turrets) if (dist(x, y, t.x, t.y) < 500) { tooClose = true; break; }
                        if (!tooClose) valid = true;
                    }
                }
                if (valid) turrets.push({ x, y, hp: 8, isTurret: true });
            }
        }

        function initRopeCoil() {
            ropePoints = [];
            let cx = lastBaseTouched.x, cy = lastBaseTouched.y;
            for (let i = 0; i <= ROPE_SEGMENTS; i++) {
                let a = i * 0.3, r = 10 + i * 1.0;
                let px = cx + cos(a) * r, py = cy + sin(a) * r;
                ropePoints.push({ x: px, y: py, oldX: px, oldY: py });
            }
        }

        function draw() {
            if (gameState === "START") { drawScreen("SPACE SURVIVAL", "CLICK OR TAP TO START"); return; }
            runGameLoop();
        }

        function drawScreen(title, sub) {
            background(0); textAlign(CENTER); fill(255);
            textSize(40); text(title, width / 2, height / 2 - 20);
            textSize(20); text(sub, width / 2, height / 2 + 30);
        }

        function runGameLoop() {
            background(15);
            updateLogic();
            push();
            translate(width / 2 - player.x, height / 2 - player.y);
            drawTerrain();
            drawRope();
            drawObjects();

            // プレイヤー描画 (二等辺三角形)
            push();
            translate(player.x, player.y);
            rotate(atan2(lastMoveDir.y, lastMoveDir.x));
            if (isRespawning && respawnTimer < 30) {
                if (frameCount % 4 < 2) fill(255, 0, 0); else fill(255, 100);
            } else {
                fill(0); stroke(0, 255, 0);
            }
            triangle(10, 0, -6, 6, -6, -6); // 進行方向を向く三角形
            pop();

            pop(); // global translate pop

            drawUI();
            drawMiniMap();
            if (isInputActive && inputStartPos) drawInputUI();
        }

        function updateLogic() {
            if (isRespawning) {
                respawnTimer++;
                let t = respawnTimer / 90;
                for (let i = ropePoints.length - 1; i > 0; i--) {
                    ropePoints[i].x = lerp(ropePoints[i].x, ropePoints[i - 1].x, 0.2);
                    ropePoints[i].y = lerp(ropePoints[i].y, ropePoints[i - 1].y, 0.2);
                }
                player.x = ropePoints[ROPE_SEGMENTS].x; player.y = ropePoints[ROPE_SEGMENTS].y;
                if (t >= 1) {
                    isRespawning = false; player.x = lastBaseTouched.x; player.y = lastBaseTouched.y;
                    player.ox = player.maxOx; player.fuel = player.maxFuel; initRopeCoil();
                }
                return;
            }

            let nextX = player.x, nextY = player.y, moving = false;

            // キー操作
            if (keyIsDown(LEFT_ARROW)) { nextX -= upgradeLevels.speed; lastMoveDir = { x: -12, y: 0 }; moving = true; }
            if (keyIsDown(RIGHT_ARROW)) { nextX += upgradeLevels.speed; lastMoveDir = { x: 12, y: 0 }; moving = true; }
            if (keyIsDown(UP_ARROW)) { nextY -= upgradeLevels.speed; lastMoveDir = { x: 0, y: -12 }; moving = true; }
            if (keyIsDown(DOWN_ARROW)) { nextY += upgradeLevels.speed; lastMoveDir = { x: 0, y: 12 }; moving = true; }

            // マウス・タッチ操作
            if (isInputActive && inputStartPos) {
                let dx = mouseX - inputStartPos.x, dy = mouseY - inputStartPos.y, d = sqrt(dx * dx + dy * dy);
                if (d > 5) {
                    moving = true;
                    let speed = map(d, 0, 100, 0, upgradeLevels.speed, true);
                    let angle = atan2(dy, dx);
                    nextX += cos(angle) * speed; nextY += sin(angle) * speed;
                    lastMoveDir = { x: cos(angle) * 12, y: sin(angle) * 12 };
                }
                if (frameCount % 12 === 0) fireLaser();
            }

            // ロープ制限
            let dToBase = dist(nextX, nextY, lastBaseTouched.x, lastBaseTouched.y);
            if (dToBase > MAX_ROPE_DIST - 10) {
                let a = atan2(nextY - lastBaseTouched.y, nextX - lastBaseTouched.x);
                nextX = lastBaseTouched.x + cos(a) * (MAX_ROPE_DIST - 10);
                nextY = lastBaseTouched.y + sin(a) * (MAX_ROPE_DIST - 10);
            }

            // 移動と地形判定（燃料は減らない）
            if (getTerrain(nextX, nextY) < 0.6) {
                player.x = nextX; player.y = nextY;
            }
            player.ox -= 0.015;

            updateRopePhysics();

            bases.forEach(b => {
                if (dist(player.x, player.y, b.x, b.y) < 70) {
                    if (lastBaseTouched !== b) { lastBaseTouched = b; initRopeCoil(); }
                    player.ox = player.maxOx; player.fuel = player.maxFuel;
                    baseStock.h += player.h; player.h = 0; baseStock.o += player.o; player.o = 0;
                    baseStock.c += player.c; player.c = 0; baseStock.fe += player.fe; player.fe = 0;
                }
            });

            if (nextBaseCandidate && dist(player.x, player.y, nextBaseCandidate.x, nextBaseCandidate.y) < 60) {
                if (keyIsDown(32) || (isInputActive && dist(mouseX, mouseY, inputStartPos.x, inputStartPos.y) < 10)) {
                    buildProgress++;
                    if (buildProgress > 100) {
                        bases.push({ x: nextBaseCandidate.x, y: nextBaseCandidate.y });
                        baseStock.fe -= requiredFeForBase; requiredFeForBase *= 2; buildProgress = 0; nextBaseCandidate = null;
                    }
                } else buildProgress = 0;
            }

            if (deathDrop && dist(player.x, player.y, deathDrop.x, deathDrop.y) < 40) {
                player.h += deathDrop.h; player.o += deathDrop.o; player.c += deathDrop.c; player.fe += deathDrop.fe; deathDrop = null;
            }

            processCrystals();
            processEnemies();
            processWanderers();
            processProjectiles();

            if (frameCount % 1000 === 0) spawnEnemySwarm();
            if (wanderers.length < 32 && frameCount % 30 === 0) spawnWanderer();

            for (let i = drops.length - 1; i >= 0; i--) {
                if (dist(player.x, player.y, drops[i].x, drops[i].y) < 25) {
                    if (drops[i].type) player[drops[i].type.toLowerCase()]++;
                    else player.fe++;
                    drops.splice(i, 1);
                }
            }

            if (baseStock.fe >= requiredFeForBase && !nextBaseCandidate) spawnCandidate();
            if (dist(player.x, player.y, goal.x, goal.y) < 60) { gameState = "MISSION CLEAR!"; noLoop(); }

            if (player.ox <= 0) triggerRespawn();
        }

        function updateRopePhysics() {
            if (isRespawning) return;
            ropePoints[0].x = lastBaseTouched.x; ropePoints[0].y = lastBaseTouched.y;
            ropePoints[ROPE_SEGMENTS].x = player.x; ropePoints[ROPE_SEGMENTS].y = player.y;

            for (let i = 0; i < ropePoints.length; i++) {
                let p = ropePoints[i]; if (i === 0 || i === ROPE_SEGMENTS) continue;
                let vx = (p.x - p.oldX) * 0.96; let vy = (p.y - p.oldY) * 0.96;
                p.oldX = p.x; p.oldY = p.y; p.x += vx; p.y += vy;

                if (getTerrain(p.x, p.y) >= 0.6) { p.x = p.oldX; p.y = p.oldY; }
                for (let s of stakes) {
                    if (dist(p.x, p.y, s.x, s.y) < 14) { p.x = p.oldX; p.y = p.oldY; break; }
                }
            }
            for (let n = 0; n < 20; n++) {
                for (let i = 0; i < ROPE_SEGMENTS; i++) {
                    let p1 = ropePoints[i], p2 = ropePoints[i + 1];
                    let dx = p2.x - p1.x, dy = p2.y - p1.y, d = sqrt(dx * dx + dy * dy);
                    if (d > SEGMENT_LEN) {
                        let diff = (d - SEGMENT_LEN) / d;
                        let m1 = (i === 0) ? 0 : 0.5; let m2 = (i + 1 === ROPE_SEGMENTS) ? 0 : 0.5;
                        p1.x += dx * diff * m1; p1.y += dy * diff * m1; p2.x -= dx * diff * m2; p2.y -= dy * diff * m2;
                    }
                }
                for (let i = 0; i < ROPE_SEGMENTS; i++) {
                    let p1 = ropePoints[i], p2 = ropePoints[i + 1];
                    for (let s of stakes) resolveLineCollision(p1, p2, s.x, s.y, 14);
                }
            }
        }

        function resolveLineCollision(p1, p2, cx, cy, r) {
            let dx = p2.x - p1.x, dy = p2.y - p1.y;
            let t = ((cx - p1.x) * dx + (cy - p1.y) * dy) / (dx * dx + dy * dy);
            t = constrain(t, 0, 1);
            let closeX = p1.x + t * dx, closeY = p1.y + t * dy;
            let distToStake = dist(closeX, closeY, cx, cy);
            if (distToStake < r) {
                let pushAngle = atan2(closeY - cy, closeX - cx);
                let pushDist = r - distToStake;
                let pushX = cos(pushAngle) * pushDist, pushY = sin(pushAngle) * pushDist;
                if (p1 !== ropePoints[0] && p1 !== ropePoints[ROPE_SEGMENTS]) { p1.x += pushX * 0.5; p1.y += pushY * 0.5; }
                if (p2 !== ropePoints[0] && p2 !== ropePoints[ROPE_SEGMENTS]) { p2.x += pushX * 0.5; p2.y += pushY * 0.5; }
            }
        }

        function drawRope() {
            noFill(); stroke(180, 200, 255, 180); strokeWeight(3.5);
            beginShape();
            curveVertex(ropePoints[0].x, ropePoints[0].y);
            for (let p of ropePoints) curveVertex(p.x, p.y);
            curveVertex(ropePoints[ROPE_SEGMENTS].x, ropePoints[ROPE_SEGMENTS].y);
            endShape();
            stroke(255, 255, 0, 15); noFill();
            ellipse(lastBaseTouched.x, lastBaseTouched.y, MAX_ROPE_DIST * 2);
        }

        function processEnemies() {
            const checkBaseCollision = (e) => {
                for (let b of bases) {
                    if (dist(e.x, e.y, b.x, b.y) < 80) {
                        let angle = atan2(e.y - b.y, e.x - b.x);
                        e.x = b.x + cos(angle) * 80;
                        e.y = b.y + sin(angle) * 80;
                    }
                }
            };

            bosses.forEach(b => {
                let d = dist(player.x, player.y, b.x, b.y);
                if (b.state === "SLEEP") { if (d < 250) b.state = "AWAKE"; }
                else {
                    let vx = (player.x - b.x) / d, vy = (player.y - b.y) / d;
                    b.x += vx * 0.2; b.y += vy * 0.2;
                    if (frameCount % 30 === 0) bullets.push({ x: b.x, y: b.y, vx: vx * 4, vy: vy * 4, isEnemyBullet: true });
                }
                checkBaseCollision(b);
                if (d < 40) triggerRespawn();
            });

            enemies.forEach(e => {
                if (!e.angle) e.angle = random(TWO_PI);
                e.angle += random(-0.05, 0.05);
                e.x += cos(e.angle) * e.speed * 2.5;
                e.y += sin(e.angle) * e.speed * 2.5;

                if (getTerrain(e.x + cos(e.angle) * 20, e.y + sin(e.angle) * 20) >= 0.6) e.angle += PI;
                checkBaseCollision(e);
                if (dist(player.x, player.y, e.x, e.y) < 20) triggerRespawn();
            });

            turrets.forEach(t => {
                let d = dist(player.x, player.y, t.x, t.y);
                if (d < 400 && frameCount % 120 === 0) bullets.push({ x: t.x, y: t.y, vx: (player.x - t.x) / d * 2.5, vy: (player.y - t.y) / d * 2.5, isEnemyBullet: true });
            });
        }

        function processWanderers() {
            const checkBaseCollision = (w) => {
                for (let b of bases) {
                    if (dist(w.x, w.y, b.x, b.y) < 80) {
                        let angle = atan2(w.y - b.y, w.x - b.x);
                        w.x = b.x + cos(angle) * 80;
                        w.y = b.y + sin(angle) * 80;
                    }
                }
            };

            wanderers.forEach(w => {
                let d = dist(player.x, player.y, w.x, w.y);
                if (d < 250) {
                    let vx = (player.x - w.x) / d; let vy = (player.y - w.y) / d;
                    w.x += vx * w.speed; w.y += vy * w.speed;
                } else {
                    w.angle += random(-0.1, 0.1);
                    w.x += cos(w.angle) * (w.speed * 0.5); w.y += sin(w.angle) * (w.speed * 0.5);
                    if (getTerrain(w.x + cos(w.angle) * 20, w.y + sin(w.angle) * 20) >= 0.6) w.angle += PI;
                }
                w.x = constrain(w.x, 50, worldSize - 50); w.y = constrain(w.y, 50, worldSize - 50);
                checkBaseCollision(w);
                if (d < 20) triggerRespawn();
            });
        }

        function processProjectiles() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i]; b.x += b.vx; b.y += b.vy;

                let hitStakeIndex = -1;
                for (let k = 0; k < stakes.length; k++) {
                    if (dist(b.x, b.y, stakes[k].x, stakes[k].y) < 15) { hitStakeIndex = k; break; }
                }

                let hitTerrain = getTerrain(b.x, b.y) >= 0.6;

                if (hitTerrain || hitStakeIndex !== -1) {
                    // 反射処理 (Level 4 かつ 岩場の場合のみ反射。杭は反射せず破壊)
                    if (!b.isEnemyBullet && laserLevel === 4 && (b.reflections || 0) < 3 && hitTerrain) {
                        // ビリヤード反射
                        let prevX = b.x - b.vx;
                        let prevY = b.y - b.vy;
                        let hitX = getTerrain(prevX, b.y) < 0.6;
                        let hitY = getTerrain(b.x, prevY) < 0.6;

                        if (hitX) b.vx *= -1;
                        else if (hitY) b.vy *= -1;
                        else { b.vx *= -1; b.vy *= -1; }

                        b.reflections = (b.reflections || 0) + 1;
                        b.x += b.vx; b.y += b.vy;
                    } else {
                        for (let p = 0; p < 6; p++) particles.push({ x: b.x, y: b.y, vx: random(-3, 3), vy: random(-3, 3), life: 12 });
                        if (hitStakeIndex !== -1 && !b.isEnemyBullet) {
                            let s = stakes[hitStakeIndex];
                            s.hp = (s.hp || 4) - 1;
                            if (s.hp <= 0) {
                                drops.push({ x: s.x, y: s.y, type: null });
                                stakes.splice(hitStakeIndex, 1);
                            }
                        }
                        bullets.splice(i, 1); continue;
                    }
                }

                if (b.isEnemyBullet && dist(b.x, b.y, player.x, player.y) < 15) { triggerRespawn(); bullets.splice(i, 1); continue; }

                if (!b.isEnemyBullet) {
                    let targets = [...enemies, ...wanderers, ...turrets, ...bosses];
                    for (let t of targets) {
                        if (dist(b.x, b.y, t.x, t.y) < 35) {
                            if (!b.hitIds) b.hitIds = [];
                            if (!b.hitIds.includes(t)) {
                                t.hp--; b.hitIds.push(t);
                                for (let p = 0; p < 4; p++) particles.push({ x: t.x, y: t.y, vx: random(-4, 4), vy: random(-4, 4), life: 10 });
                                if (t.hp <= 0) {
                                    if (t.isBoss) {
                                        for (let k = 0; k < 20; k++) drops.push({ x: t.x + random(-40, 40), y: t.y + random(-40, 40) });
                                        bosses = bosses.filter(bo => bo !== t);
                                    } else if (t.isTurret) {
                                        for (let k = 0; k < 8; k++) drops.push({ x: t.x + random(-20, 20), y: t.y + random(-20, 20) });
                                        turrets = turrets.filter(tr => tr !== t);
                                    } else if (t.isWanderer) { let type = random(['H', 'O', 'C', null]); drops.push({ x: t.x, y: t.y, type: type }); wanderers = wanderers.filter(w => w !== t); }
                                    else { drops.push({ x: t.x, y: t.y }); enemies = enemies.filter(e => e !== t); }
                                }
                            }
                            if (laserLevel === 1) { bullets.splice(i, 1); break; }
                        }
                    }
                }
                if (i < bullets.length && dist(b.x, b.y, player.x, player.y) > 800) bullets.splice(i, 1);
            }
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); });
        }

        function drawObjects() {
            fill(0, 200, 255); stroke(255); strokeWeight(2); rect(goal.x - 10, goal.y - 60, 20, 60); ellipse(goal.x, goal.y - 60, 30, 10);
            bases.forEach(b => { stroke(100, 150, 255); noFill(); strokeWeight(2); rect(b.x - 40, b.y - 40, 80, 80); });
            if (deathDrop) { stroke(255, 50, 50); strokeWeight(3); line(deathDrop.x - 15, deathDrop.y - 15, deathDrop.x + 15, deathDrop.y + 15); line(deathDrop.x + 15, deathDrop.y - 15, deathDrop.x - 15, deathDrop.y + 15); }

            crystals.forEach(c => { noStroke(); fill(255, 0, 255); text(c.type, c.x, c.y); });
            drops.forEach(d => { fill(100, 150, 255); text(d.type ? d.type : "Fe", d.x, d.y); });
            enemies.forEach(e => { fill(255, 0, 0); noStroke(); ellipse(e.x, e.y, 8); });
            wanderers.forEach(w => { fill(200, 0, 50); noStroke(); ellipse(w.x, w.y, 12); });
            turrets.forEach(t => { fill(255, 100, 0); rect(t.x - 20, t.y - 20, 40, 40); fill(255); text("T", t.x, t.y + 5); });
            bosses.forEach(b => { fill(b.state === "SLEEP" ? 40 : color(255, 0, 0)); stroke(255, 50); rect(b.x - 30, b.y - 30, 60, 60); if (b.state === "AWAKE") { fill(255); text("GUARD: " + b.hp, b.x, b.y - 40); } });
            stakes.forEach(s => { fill(150); stroke(50); rect(s.x - 5, s.y - 5, 10, 10); line(s.x - 5, s.y - 5, s.x + 5, s.y + 5); });
            bullets.forEach(b => { stroke(b.isEnemyBullet ? [255, 0, 0] : [255, 255, 0]); strokeWeight(b.isEnemyBullet ? 1 : 2); line(b.x, b.y, b.x - b.vx * 1.5, b.y - b.vy * 1.5); });
            particles.forEach(p => { stroke(255, 180, 0); strokeWeight(1.5); point(p.x, p.y); });
            if (nextBaseCandidate) { noFill(); stroke(255, 255, 0); strokeWeight(2); ellipse(nextBaseCandidate.x, nextBaseCandidate.y, 80); if (buildProgress > 0) { fill(255, 255, 0); rect(nextBaseCandidate.x - 20, nextBaseCandidate.y - 60, buildProgress * 0.4, 6); } }
        }

        function drawMiniMap() {
            let ms = 120, mx = width - ms - 10, my = 10;
            fill(0, 180); stroke(255, 50); rect(mx, my, ms, ms);
            let sc = ms / worldSize;
            fill(0, 255, 255); text("★", mx + goal.x * sc, my + goal.y * sc);
            if (deathDrop) { fill(255, 0, 0); text("×", mx + deathDrop.x * sc, my + deathDrop.y * sc); }
            bosses.forEach(b => { fill(255, 0, 0); ellipse(mx + b.x * sc, my + b.y * sc, 4); });
            wanderers.forEach(w => { fill(200, 0, 50); ellipse(mx + w.x * sc, my + w.y * sc, 3); });
            turrets.forEach(t => { fill(255, 0, 0); textSize(8); text("T", mx + t.x * sc, my + t.y * sc); });
            stakes.forEach(s => { fill(150); rect(mx + s.x * sc, my + s.y * sc, 2, 2); });
            fill(100, 150, 255); bases.forEach(b => rect(mx + b.x * sc - 2, my + b.y * sc - 2, 4, 4));
            fill(0, 255, 0); ellipse(mx + player.x * sc, my + player.y * sc, 4);
        }

        function spawnStake() { let x = random(worldSize), y = random(worldSize); if (getTerrain(x, y) < 0.6 && dist(x, y, 2000, 2000) > 150) stakes.push({ x, y, hp: 4 }); else spawnStake(); }
        function spawnCrystal() { let x = random(worldSize), y = random(worldSize); if (getTerrain(x, y) < 0.6) crystals.push({ x, y, type: random(['H', 'O', 'C']) }); else spawnCrystal(); }
        function spawnBoss() { let x = random(worldSize), y = random(worldSize); if (getTerrain(x, y) < 0.6 && dist(x, y, 2000, 2000) > 1000) bosses.push({ x, y, hp: 16, state: "SLEEP", isBoss: true }); else spawnBoss(); }
        function spawnWanderer() { let x = random(worldSize), y = random(worldSize); if (getTerrain(x, y) < 0.6 && dist(x, y, 2000, 2000) > 500) wanderers.push({ x, y, hp: 3, speed: 1.8, angle: random(TWO_PI), isWanderer: true }); else spawnWanderer(); }
        function spawnCandidate() { let a = random(TWO_PI), r = random(MAX_ROPE_DIST * 0.7, MAX_ROPE_DIST * 0.9); let tx = lastBaseTouched.x + cos(a) * r, ty = lastBaseTouched.y + sin(a) * r; if (tx > 50 && tx < worldSize - 50 && ty > 50 && ty < worldSize - 50 && getTerrain(tx, ty) < 0.6) nextBaseCandidate = { x: tx, y: ty }; }
        function spawnEnemySwarm() { let x = random(worldSize), y = random(worldSize); for (let i = 0; i < 6; i++) enemies.push({ x: x + random(60), y: y + random(60), size: 10, hp: 1, speed: 0.3 }); }
        function processCrystals() { for (let i = crystals.length - 1; i >= 0; i--) { if (dist(player.x, player.y, crystals[i].x, crystals[i].y) < 25) { let type = crystals[i].type; player[type.toLowerCase()]++; if (type === 'O') { player.oCount++; if (player.oCount >= 4) { player.maxOx += 5; player.oCount = 0; } } if (type === 'H') { player.hCount++; if (player.hCount >= 4) { player.maxFuel += 5; player.hCount = 0; } } crystals.splice(i, 1); spawnCrystal(); } } }
        function triggerRespawn() { if (isRespawning) return; if (player.h + player.o + player.c + player.fe > 0) deathDrop = { x: player.x, y: player.y, h: player.h, o: player.o, c: player.c, fe: player.fe }; for (let i = 0; i < 20; i++) particles.push({ x: player.x, y: player.y, vx: random(-5, 5), vy: random(-5, 5), life: 30 }); isRespawning = true; respawnTimer = 0; respawnStartPos = { x: player.x, y: player.y }; player.h = 0; player.o = 0; player.c = 0; player.fe = 0; isInputActive = false; }
        function getTerrain(x, y) { return noise(floor(x / 50) * 50 * 0.006, floor(y / 50) * 50 * 0.006); }
        function drawTerrain() { noStroke(); fill(50); for (let x = player.x - 400; x < player.x + 400; x += 50) { for (let y = player.y - 350; y < player.y + 350; y += 50) { if (getTerrain(x, y) >= 0.6) rect(floor(x / 50) * 50, floor(y / 50) * 50, 50, 50); } } }
        function drawUI() {
            drawGauge(10, 10, "OX", player.ox, player.maxOx);
            fill(255); noStroke(); textSize(11);
            text(`[BAG] H:${player.h} O:${player.o} C:${player.c} Fe:${player.fe}`, 10, 55);
            fill(100, 200, 255); text(`[STOCK] H:${baseStock.h} O:${baseStock.o} C:${baseStock.c} Fe:${baseStock.fe}/${requiredFeForBase}`, 10, 75);
            let cost = [0, 5, 10, 20][laserLevel];
            fill(255, 255, 0); text(`[LASER LV] ${laserLevel}`, 10, 95);
            if (dist(player.x, player.y, lastBaseTouched.x, lastBaseTouched.y) < 70 && laserLevel < 4) { fill(255, 100, 255); text(`CLICK UI OR PRESS [U] TO UPGRADE (Cost: ${cost}C)`, 10, 115); }
        }
        function drawGauge(x, y, label, val, maxVal) { noStroke(); fill(50); rect(x + 30, y, 150, 15); let gCol = val / maxVal > 0.5 ? color(0, 255, 0) : (val / maxVal > 0.25 ? color(255, 255, 0) : color(255, 0, 0)); fill(gCol); rect(x + 30, y, (val / maxVal) * 150, 15); fill(255); text(label, x, y + 12); }
        function drawInputUI() { noFill(); stroke(255, 100); ellipse(inputStartPos.x, inputStartPos.y, 60); line(inputStartPos.x, inputStartPos.y, mouseX, mouseY); }
        function mousePressed() { if (gameState === "START") { gameState = "PLAY"; return false; } if (mouseX < 200 && mouseY > 90 && mouseY < 120) upgradeLaser(); isInputActive = true; inputStartPos = { x: mouseX, y: mouseY }; fireLaser(); return false; }
        function mouseReleased() { isInputActive = false; inputStartPos = null; return false; }
        function touchStarted() { return mousePressed(); }
        function touchEnded() { return mouseReleased(); }
        function keyPressed() { if (key === ' ') fireLaser(); if (key === 'u' || key === 'U') upgradeLaser(); }
        function upgradeLaser() { let cost = [0, 5, 10, 20][laserLevel]; if (dist(player.x, player.y, lastBaseTouched.x, lastBaseTouched.y) < 70 && laserLevel < 4 && baseStock.c >= cost) { baseStock.c -= cost; laserLevel++; } }
        function fireLaser() { if (laserLevel <= 2 || laserLevel === 4) bullets.push({ x: player.x, y: player.y, vx: lastMoveDir.x, vy: lastMoveDir.y }); else if (laserLevel === 3) { bullets.push({ x: player.x, y: player.y, vx: lastMoveDir.x, vy: lastMoveDir.y, offset: 5 }); bullets.push({ x: player.x, y: player.y, vx: lastMoveDir.x, vy: lastMoveDir.y, offset: -5 }); } }
    </script>
</body>

</html>